# only load mod where specified
if [[ -n "$ZSH_DEBUGRC" ]]; then
  zmodload zsh/zprof
fi

# history settings
# Add these near the top of your .zshrc
HISTFILE=~/.zsh_history
HISTSIZE=50000
SAVEHIST=50000
# History settings
setopt SHARE_HISTORY          # Share history between sessions
setopt INC_APPEND_HISTORY     # Add commands to history immediately
setopt EXTENDED_HISTORY       # Add timestamps to history
setopt HIST_FIND_NO_DUPS     # Don't display duplicates during searches
setopt HIST_IGNORE_ALL_DUPS  # Don't record duplicated entries
# other options
setopt interactivecomments

# print each path entry on a new line
pretty-path() {
    echo "${1:-$PATH}" | sed "s/:/\n/g"
}

function reload-tmux {
  tmux source-file ~/.tmux.conf
}
function reload-zsh {
  source ~/.zshrc
}

# copy a file to clipboard
function copyfile {
    # Resolve the full path of the file
    local fullpath=$(realpath $1)
    if [ ! -e $fullpath ]; then
        echo "Error: Invalid file path" >&2
        return 1
    fi

    # Copy the file path to the clipboard
    echo "file://$fullpath" | wl-copy -t text/uri-list
    echo "File path copied to clipboard: $fullpath"
}

# Load from cache immediately
autoload -U compinit
compinit

# load sheldon plugins
eval "$(sheldon source)"

# show hostname
DRACULA_DISPLAY_CONTEXT=1

# fnm completion and shell
if command -v fnm >/dev/null; then
  eval "$(fnm env --use-on-cd --shell zsh)"
fi

# Autosuggest settings
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=#707070,underline"

# custom completions
if command -v glab >/dev/null; then source <(glab completion -s zsh); fi
if command -v docker >/dev/null && ! uname -r | grep -iq microsoft; then source <(docker completion zsh); fi
if command -v gh >/dev/null; then source <(gh completion -s zsh); fi  
if command -v fzf >/dev/null; then source <(fzf --zsh); fi

function bw-setup() {
  current_status="$(bw status | jq -r .status)"
  case $current_status in
      "unauthenticated")
          echo "Please log in first with 'bw login' before setting up session"
          return 1

          ;;
      "locked")
          echo "locked, please unlock..."
          unlock_result=$(bw unlock --raw)
          if [[ "$?" -ne "0" ]]; then
            echo "Failed to unlock!"
            return 1
          fi
          export BW_SESSION="$unlock_result"
          ;;
      "unlocked")
          echo "Already unlocked"
          ;;
      *)
          echo "unknown status $current_status"
          return 1
          ;;
  esac
}

function bw-view() {
    # get all items from bitwarden
    bw_items=$(bw list items)

    # pass ID (hidden as 1st col) to fzf with details
    selected_id=$(jq -r '.[] | .id + " " + .name + " " + .login.username' <<< "$bw_items" | fzf --with-nth 2.. | awk '{print $1}')

    # check user selected an item
    if test -z "$selected_id"; then
        echo "no item selected!"
        return 1
    fi

    # filter items based on selected ID and convert to yaml
    jq -r ".[] | select(.id == \"$selected_id\")" <<< "$bw_items" | yq -p=json
}

function bw-edit() {
    # get all items from bitwarden
    bw_items=$(bw list items)

    if test -z bw_items; then
        return 1
    fi

    # pass ID (hidden as 1st col) to fzf with details
    selected_id=$(jq -r '.[] | .id + " " + .name + " " + .login.username' <<< "$bw_items" | fzf --with-nth 2.. | awk '{print $1}')

    # check user selected an item
    if test -z $selected_id; then
        echo "no item selected!"
        return 1
    fi
    echo "retrieved ID $selected_id"

    # create temp file
    tmpfile=$(mktemp)

    # write JSON to temp file
    jq -r ".[] | select(.id == \"$selected_id\")" <<< "$bw_items" >$tmpfile

    # check file not empty
    if test -z "$(cat -A $tmpfile)"; then
        echo "error, json is empty!"
        return 1
    fi

    # open in editor (this blocks until editor closes)
    $EDITOR $tmpfile

    if test "$(cat $tmpfile)" = "$item_json"; then
        echo "no changes made, exiting..."
        rm -f $tmpfile
        return 0
    fi

    # update bitwarden with edited JSON
    echo "sending updated JSON to bitwarden..."
    cat $tmpfile | bw encode | bw edit item $selected_id

    # cleanup
    rm -f $tmpfile

    echo "Item $selected_id updated successfully"
}

# control left/right because im lazy and dont want to un-learn
bindkey "^[[1;5C" forward-word
bindkey "^[[1;5D" backward-word

# Bind Ctrl-N and Ctrl-P to next/previous history commands
bindkey '^N' down-history        # Ctrl-N for next command
bindkey '^P' up-history          # Ctrl-P for previous command

# otherwise cant delete words if pasted over new lines
bindkey '^?' backward-delete-char
bindkey '^W' backward-kill-word  # This will use WORDCHARS


autoload -U select-word-style

# only treat . and - as special chars so c-w doesnt delete whole words
export WORDCHARS='.-_'


# fzf tab config
# enable tab completion on empty line
zstyle ':completion:*' insert-tab false
# show both commands and files on empty line
zstyle ':completion:*' completer _complete _files _expand
# force file completion to show all files including directories
zstyle ':completion:*' file-patterns '*:all-files'
# group completions by type
zstyle ':completion:*' group-name ''
# # disable sort when completing `git checkout`
zstyle ':completion:*:git-checkout:*' sort false
# set descriptions format to enable group support
# NOTE: don't use escape sequences (like '%F{red}%d%f') here, fzf-tab will ignore them
zstyle ':completion:*:descriptions' format '[%d]'
# set list-colors to enable filename colorizing
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# force zsh not to show completion menu, which allows fzf-tab to capture the unambiguous prefix
zstyle ':completion:*' menu no
# preview directory's content with eza when completing cd
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1 --color=always $realpath'
# custom fzf flags
# NOTE: fzf-tab does not follow FZF_DEFAULT_OPTS by default
zstyle ':fzf-tab:*' fzf-flags --color=fg:1,fg+:2 --bind=tab:accept
# To make fzf-tab follow FZF_DEFAULT_OPTS.
# NOTE: This may lead to unexpected behavior since some flags break this plugin. See Aloxaf/fzf-tab#455.
zstyle ':fzf-tab:*' use-fzf-default-opts yes
# switch group using `<` and `>`
zstyle ':fzf-tab:*' switch-group '<' '>'

# fzf tmux popup (REMOVED, breaks when not in tmux)
# zstyle ':fzf-tab:*' fzf-command ftb-tmux-popup

# apply to all command
zstyle ':fzf-tab:*' popup-min-size 80 12
# preview directory's content with eza when completing cd
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1a --color=always $realpath'


# eza aliases stolen from here: https://github.com/MohamedElashri/eza-zsh/blob/main/eza-zsh.plugin.zsh
alias ..='cd ..'
alias l='eza --long --icons -bF' # Extended details with binary sizes and type indicators
alias ll='eza --long -a' # Long format, including hidden files
alias la='eza -a --group-directories-first' # Show all files, with directories listed first
alias lx='eza -a -l --group-directories-first --extended' # Show all files and extended attributes, directories first
alias lT='eza --tree --long' # Tree view with extended details
alias lr='eza --long --modified --sort=modified -r' # sort by modified desc
function lP() {
  local target="${1:-.}"
  local resolved=$(realpath "$target")
  find "$resolved" -maxdepth 1
}


# stolen from OMZ tmux plugin
# Essential tmux aliases
alias ta='tmux attach'     # Attach to a session
alias ts='tmux new-session -s' # Start new session with name
alias tl='tmux list-sessions' # List all sessions


# tmux escape chars for `next-prompt` and `previous-prompt`
function tmux_preexec() {
  print -Pn '\e]133;A\a'
}
function tmux_precmd() {
  print -Pn '\e]133;B\a'
}


# Add hooks
autoload -U add-zsh-hook
add-zsh-hook preexec tmux_preexec
add-zsh-hook precmd tmux_precmd


if [ -e $HOME/.nix-profile/etc/profile.d/nix.sh ]; then . $HOME/.nix-profile/etc/profile.d/nix.sh; fi # added by Nix installer

if [ -e $HOME/.config/zshrclocal ]; then
  source $HOME/.config/zshrclocal
fi

if [[ -n "$ZSH_DEBUGRC" ]]; then
  zprof
fi
