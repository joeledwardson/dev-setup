# only load mod where specified
if [[ -n "$ZSH_DEBUGRC" ]]; then
  zmodload zsh/zprof
fi

# history settings (see https://zsh.sourceforge.io/Doc/Release/Parameters.html)
# Add these near the top of your .zshrc
HISTFILE=~/.zsh_history
HISTSIZE=50000
# not sure why shellcheck doesnt like this one below, its a documented option?
# shellcheck disable=SC2034
SAVEHIST=50000
# History settings
setopt SHARE_HISTORY          # Share history between sessions
setopt INC_APPEND_HISTORY     # Add commands to history immediately
setopt EXTENDED_HISTORY       # Add timestamps to history
setopt HIST_FIND_NO_DUPS     # Don't display duplicates during searches
setopt HIST_IGNORE_ALL_DUPS  # Don't record duplicated entries
# other options
setopt interactivecomments

# print each path entry on a new line
pretty-path() {
    echo "${1:-$PATH}" | sed "s/:/\n/g"
}

function reload-tmux {
  tmux source-file ~/.config/tmux/tmux.conf
}

# copy a file to clipboard
function copyfile {
    # Resolve the full path of the file
    local -r fullpath=$(realpath "$1")
    if [ ! -e "$fullpath" ]; then
        echo "Error: Invalid file path" >&2
        return 1
    fi

    # Copy the file path to the clipboard
    echo "file://$fullpath" | wl-copy -t text/uri-list
    echo "File path copied to clipboard: $fullpath"
}

# Load from cache immediately
autoload -U compinit
compinit

# Load bash completions compatibility for tools like Terraform
autoload -U +X bashcompinit && bashcompinit

# load sheldon plugins
eval "$(sheldon source)"

# show hostname
# shellcheck disable=SC2034
DRACULA_DISPLAY_CONTEXT=1

# fnm completion and shell
if command -v fnm >/dev/null; then
  eval "$(fnm env --use-on-cd --shell zsh)"
fi

# Autosuggest settings
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE="fg=#707070,underline"

# add navi repos if not there already
if command -v navi >/dev/null; then
    if [[ ! -d "$HOME/.local/share/navi/cheats/denisidoro__cheats" ]]; then
        navi repo add denisidoro/cheats
    fi
fi

# see https://docs.aws.amazon.com/cli/v1/userguide/cli-configure-completion.html
function setup-aws () {
    local aws_path aws_dir aws_completer
    aws_path=$(readlink -f "$(which aws)")
    aws_dir=$(dirname "$aws_path")
    aws_completer="$aws_dir/aws_completer"

    # check aws completer exists
    if [[ ! -e "$aws_completer" ]]; then
        echo "AWS completion path does not exist!" >&2
        return
    fi

    complete -C "$aws_completer" aws
}

# custom completions
if command -v glab >/dev/null; then source <(glab completion -s zsh); fi
if command -v docker >/dev/null && ! uname -r | grep -iq microsoft; then source <(docker completion zsh); fi
if command -v gh >/dev/null; then source <(gh completion -s zsh); fi
if command -v fzf >/dev/null; then source <(fzf --zsh); fi
if command -v terraform >/dev/null; then complete -o nospace -C terraform terraform; fi
if command -v aws >/dev/null; then setup-aws; fi

# setup direnv
if command -v direnv >/dev/null; then eval "$(direnv hook zsh)"; fi

# nvim alias to clear session and start
alias nvimc="nvim -c 'lua require(\"session_manager\").delete_current_dir_session()'"

# i dont like the name status default as sometimes i want git log --patch
alias gl='git log'

# change bitwarden data directory to work location to separate from personal
function bw-use-work () {
    BITWARDENCLI_APPDATA_DIR="$(realpath ~/.config/bw-work)"
    export BITWARDENCLI_APPDATA_DIR
}

# find and view a bitwarden entry
function bw-view() {
    # get all items from bitwarden
    bw_items=$(bw list items)

    # pass ID (hidden as 1st col) to fzf with details
    selected_id=$(jq -r '.[] | .id + " " + .name + " " + .login.username' <<< "$bw_items" | fzf --with-nth 2.. | awk '{print $1}')

    # check user selected an item
    if test -z "$selected_id"; then
        echo "no item selected!"
        return 1
    fi

    # filter items based on selected ID and convert to yaml
    jq -r ".[] | select(.id == \"$selected_id\")" <<< "$bw_items" | yq -p=json
}

# find and edit a bitwarden entry
function bw-edit() {
    # get all items from bitwarden
    bw_items=$(bw list items)

    if test -z bw_items; then
        return 1
    fi

    # pass ID (hidden as 1st col) to fzf with details
    selected_id=$(jq -r '.[] | .id + " " + .name + " " + .login.username' <<< "$bw_items" | fzf --with-nth 2.. | awk '{print $1}')

    # check user selected an item
    if test -z "$selected_id"; then
        echo "no item selected!"
        return 1
    fi
    echo "retrieved ID $selected_id"

    # create temp file
    tmpfile=$(mktemp)

    # write JSON to temp file
    jq -r ".[] | select(.id == \"$selected_id\")" <<< "$bw_items" >"$tmpfile"

    # check file not empty
    if test -z "$(cat -A "$tmpfile")"; then
        echo "error, json is empty!"
        return 1
    fi

    # open in editor (this blocks until editor closes)
    $EDITOR "$tmpfile"

    if test "$(cat "$tmpfile")" = "$item_json"; then
        echo "no changes made, exiting..."
        rm -f "$tmpfile"
        return 0
    fi

    # update bitwarden with edited JSON
    echo "sending updated JSON to bitwarden..."
    cat "$tmpfile" | bw encode | bw edit item "$selected_id"

    # cleanup
    rm -f "$tmpfile"

    echo "Item $selected_id updated successfully"
}

# get the latest gitlab CI/CD pipeline and view it (quicker version of `gitlab ci list`, manually coping ID and then `gitlab ci view <ID>`)
function check-glab-ci {
    glab ci list --output json --per-page 1 | jq -r '.[0].id' | xargs -I {} glab ci view #{}
}

# encode a URI (useful in postgres passwords for connection strings)
function encode-uri {
    if [[ -z "$1" ]]; then
        printf "Error: argument must be supplied\n" >&2
        return 1;
    fi
    # pass $pwd as a raw string to avoid any escaping to jq, then apply the @uri encoding
    jq -rn --arg pwd "$1" '$pwd | @uri'
}

# control left/right because im lazy and dont want to un-learn
bindkey "^[[1;5C" forward-word
bindkey "^[[1;5D" backward-word

# Bind Ctrl-N and Ctrl-P to next/previous history commands
bindkey '^N' down-history        # Ctrl-N for next command
bindkey '^P' up-history          # Ctrl-P for previous command

# otherwise cant delete words if pasted over new lines
bindkey '^?' backward-delete-char
bindkey '^W' backward-kill-word  # This will use WORDCHARS


autoload -U select-word-style

# only treat . and - as special chars so c-w doesnt delete whole words
export WORDCHARS='.-_'


# fzf tab config
# enable tab completion on empty line
zstyle ':completion:*' insert-tab false
# show both commands and files on empty line
zstyle ':completion:*' completer _complete _files _expand
# force file completion to show all files including directories
zstyle ':completion:*' file-patterns '*:all-files'
# group completions by type
zstyle ':completion:*' group-name ''
# # disable sort when completing `git checkout`
zstyle ':completion:*:git-checkout:*' sort false
# set descriptions format to enable group support
# NOTE: don't use escape sequences (like '%F{red}%d%f') here, fzf-tab will ignore them
zstyle ':completion:*:descriptions' format '[%d]'
# set list-colors to enable filename colorizing
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
# force zsh not to show completion menu, which allows fzf-tab to capture the unambiguous prefix
zstyle ':completion:*' menu no
# preview directory's content with eza when completing cd
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1 --color=always $realpath'
# custom fzf flags
# NOTE: fzf-tab does not follow FZF_DEFAULT_OPTS by default
zstyle ':fzf-tab:*' fzf-flags --color=fg:1,fg+:2 --bind=tab:accept
# To make fzf-tab follow FZF_DEFAULT_OPTS.
# NOTE: This may lead to unexpected behavior since some flags break this plugin. See Aloxaf/fzf-tab#455.
zstyle ':fzf-tab:*' use-fzf-default-opts yes
# switch group using `<` and `>`
zstyle ':fzf-tab:*' switch-group '<' '>'

# fzf tmux popup (REMOVED, breaks when not in tmux)
# zstyle ':fzf-tab:*' fzf-command ftb-tmux-popup

# apply to all command
zstyle ':fzf-tab:*' popup-min-size 80 12
# preview directory's content with eza when completing cd
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1a --color=always $realpath'


# eza aliases stolen from here: https://github.com/MohamedElashri/eza-zsh/blob/main/eza-zsh.plugin.zsh
alias ..='cd ..'
alias l='eza --long --icons -bF' # Extended details with binary sizes and type indicators
alias ll='eza --long -a' # Long format, including hidden files
alias la='eza -a --group-directories-first' # Show all files, with directories listed first
alias lx='eza -a -l --group-directories-first --extended' # Show all files and extended attributes, directories first
alias lT='eza --tree --long' # Tree view with extended details
alias lr='eza --long --modified --sort=modified -r' # sort by modified desc
function lP() {
  local target="${1:-.}"
  local resolved=$(realpath "$target")
  find "$resolved" -maxdepth 1
}


# stolen from OMZ tmux plugin
# Essential tmux aliases
alias ta='tmux attach'     # Attach to a session
alias ts='tmux new-session -s' # Start new session with name
alias tl='tmux list-sessions' # List all sessions


# tmux escape chars for `next-prompt` and `previous-prompt`
function tmux_preexec() {
  print -Pn '\e]133;A\a'
}
function tmux_precmd() {
  print -Pn '\e]133;B\a'
}

zvm_vi_yank () {
	zvm_yank
  echo "pls"
	printf %s "${CUTBUFFER}" | wl-copy
	zvm_exit_visual_mode
}
# Add hooks
autoload -U add-zsh-hook
add-zsh-hook preexec tmux_preexec
add-zsh-hook precmd tmux_precmd


if [ -e "$HOME"/.nix-profile/etc/profile.d/nix.sh ]; then . "$HOME"/.nix-profile/etc/profile.d/nix.sh; fi # added by Nix installer

if [ -e "$HOME"/.config/zshrclocal ]; then
  source "$HOME"/.config/zshrclocal
fi

if [[ -n "$ZSH_DEBUGRC" ]]; then
  zprof
fi

fastfetch
